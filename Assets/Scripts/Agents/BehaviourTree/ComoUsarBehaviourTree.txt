---Guía para hacer el árbol---
Todas las clases que hay aquí usa BehaviourTree.

Sequence: Nodo que actúa como un And. Si (y solo si) ocurre un Check, realizar un Task.

Selector: Nodo que actúa como un Or. O una rama, u otra rama pero nunca ninguna.

Task___: Las tareas que tiene que hacer. TaskPatrol, TaskAttack... Derivan de TreeNode.
En override Evaluate() se define el comportamiento como tal y se devolverá RUNNING, SUCCESS
o FAILURE.

Check___: Checkea una condición y su Evaluate devuelve SUCCESS o FAILURE. Deriva de TreeNode.
Ej: CheckEnemy. Si hay un enemigo en su rango devuelve SUCCESS y si no devuelve FAILURE.
Si es SUCCESS se pasa al nodo de la tarea (Task) que debe realizar. Debe de pasar referencias
al selector para que se las pase a la task.
Ej: si CheckEnemy es SUCCESS -> TaskAttack. Esto estaría dentro de un Sequence. Debe guardar
la referencia al enemigo, pasarla al selector y que éste se la pase a TaskAttack.

___BT: El árbol de cada agente. GigantBT, ArcherBT... Deriva de Tree. Aquí se pueden definir
variables globales a todos los nodos, por ejemplo la velocidad. El árbol se escribe en
SetUpTree(). La raíz es un Selector.
 
Ejemplo de árbol con lo anterior:

			[SELECTOR] (raíz)
				|
			------------------
			|		 |
		    [SEQUENCE]	  {TaskPatrol}
			|
		    ----------
		    |        |
	   (CheckEnemy)  {TaskAttack}

Por defecto patrulla. Si detecta a un enemigo en su campo de visión, atacarlo. Si no detecta,
continuar patrullando.